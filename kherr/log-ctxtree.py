#
# Copyright (c) 2010 Secure Endpoints Inc.
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

#
# This is a helper utility for processing debug output files that are
# generated by the Network Identity Manager application (Options ->
# General -> Log trace events).
#
# The generated debug log file contains log entries from multiple
# threads and from multiple execution contexts.  The utility generates
# a tree of execution contexts that trace out the control flow across
# threads and child contexts.
#
# When analyzing log files from debug builds, the output is much
# easier to parse as thread IDs are translated to plug-in names and we
# also have a trace of messages that were handled by each thread under
# each execution context.  (Use the '-m' option to generate message
# traces)
#
# E.g.:
#  C:\stuff> log-ctxtree.py %TEMP%\nidmdbg.log
#
# ...
#     [41] Begin: Renewing credentials
#       Thread: ['AfsCred', 'Krb5Cred', 'KCACred', 'GenericX509Provider', 'KeyStoreCred', 'Krb4Cred', '436', '764']
#       [51] Begin: Renewing credentials for asanka@YOUR-FILE-SYSTEM.COM
#         Thread: ['AfsCred', 'Krb5Cred', 'Krb4Cred', 'GenericX509Provider', 'KeyStoreCred', 'KCACred', '436', '764']         [64] Begin: Renewing Kerberos v5 tickets
#           Thread: ['Krb5Cred']
#         [65] Begin: Renewing Kerberos v4 credentials
#           Thread: ['Krb4Cred']
#         [70] Begin: Renewing KCA Cert
#           Thread: ['KCACred']
#         [74] Begin: Getting AFS tokens...
#           Thread: ['AfsCred']
# ...
#
# The above (truncated) trace shows that context id [41] was a
# credentials renewal.  The 'Thread:' line lists the threads that have
# participated in the context.  Context [51] was a child of [41] etc.

import re
import getopt
import sys

class Context:
    def __init__(self, cid, cp, desc):
        self.cid = cid
        self.parent = cp
        self.desc = desc
        self.threads = set()
        self.messages = set()

def thname(ts, tid):
    if tid in ts:
        return ts[tid]
    else:
        return str(tid)

def printctx(cs, ts, c, l):
    indent = '  '*l
    print indent, '[%(ctx)d] Begin: %(desc)s' % { 'ctx': c.cid, 'desc': c.desc }
    print indent, '  Thread:', map(lambda x: thname(ts, x), c.threads)
    for msg in c.messages:
        print indent, '    Msg:', msg

    for cc in cs:
        if cs[cc].parent == c.cid:
            printctx(cs, ts, cs[cc], l + 1)

def main():
    track_messages = False

    re_begin      = re.compile(r"..:..:..\.... \[(.*?)\] Begin: (.*?) \(child of \[(.*?)\]\)")
    re_begin_root = re.compile(r"..:..:..\.... \[(.*?)\] Begin: (.*)")
    re_handle_b   = re.compile(r"..:..:..\.... ([0-9]+)\[(.*?)\] Debug\(1\): Handling message  (.*)")
    re_handle_e   = re.compile(r"..:..:..\.... ([0-9]+)\[(.*?)\] Debug\(1\): Done handling message")
    re_thrd       = re.compile(r"..:..:..\.... ([0-9]+)\[(.*?)\] .*")
    re_tid        = re.compile(r"..:..:..\.... \[DBG\] Thread ID: \(([0-9]+)\) (.*?) by (.*)")
    re_dbg        = re.compile(r"..:..:..\.... \[DBG\] .*")

    ctxs = dict()
    threads = dict()

    try:
        opts, args = getopt.getopt(sys.argv[1:], "m")
    except getopt.GetoptError, err:
        print str(err)
        sys.exit(1)

    for opt in opts:
        if opt[0] == "-m":
            track_messages = True

    if len(args) == 0:
        print "Need filename of log file"
        sys.exit(2)

    f = open(args[0])

    try:
        for line in f:
            m = re_begin.match(line)
            if m:
                cid = int(m.group(1))
                desc = m.group(2)
                cp = int(m.group(3))
                if cid in ctxs:
                    ctxs[cid].parent = cp
                    ctxs[cid].desc = desc
                else:
                    ctxs[cid] = Context(cid, cp, desc)

                continue

            m = re_begin_root.match(line)
            if m:
                cid = int(m.group(1))
                desc = m.group(2)
                if cid in ctxs:
                    ctxs[cid].desc = desc
                else:
                    ctxs[cid] = Context(cid, None, desc)
                continue

            m = re_handle_b.match(line)
            if m:
                thrd = int(m.group(1))
                cid = int(m.group(2))
                msg = m.group(3)
                if cid not in ctxs:
                    ctx = Context(cid, None, None)
                else:
                    ctx = ctxs[cid]

                ctx.threads.add(thrd)
                if track_messages:
                    ctx.messages.add('(' + thname(threads, thrd) + ') ' + msg[0:40])

            m = re_thrd.match(line)
            if m:
                thrd = int(m.group(1))
                cid = int(m.group(2))
                if cid not in ctxs:
                    ctx = Context(cid, None, None)
                    ctxs[cid] = ctx
                else:
                    ctx = ctxs[cid]
            
                ctx.threads.add(thrd)
                continue

            m = re_tid.match(line)
            if m:
                thrd = int(m.group(1))
                desc = m.group(2)
                threads[thrd] = desc

    finally:
        f.close()

    for cid in ctxs:
        if not ctxs[cid].parent:
            printctx(ctxs, threads, ctxs[cid], 0)

if __name__ == "__main__":
    main()
